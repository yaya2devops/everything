/// <reference types="node" />
type UnsafeDataContext = {
    field?: string[];
};
type NullData = {
    readonly string: null;
    readonly boolean: null;
    readonly number: null;
    readonly integer: null;
    readonly url: null;
    enum(allowedValues: unknown[]): null;
    key(key: string): NullData;
    optionalKey(key: string): NullData;
    readonly array: null;
    index(index: number): NullData;
};
/**
 * NOTE: should be moved to a separate package in case this pattern is found to be useful
 */
export declare class UnsafeData {
    protected data: unknown;
    protected context: UnsafeDataContext;
    constructor(data: unknown, context?: UnsafeDataContext);
    protected get field(): string;
    protected addKeyToField(key: string): string[];
    protected fieldWithKey(key: string): string;
    /**
     * Returns undefined if the key is not present on the object. Note that this doesn't check for null.
     */
    optionalKey(key: string): UnsafeData | undefined;
    key(key: string): UnsafeData;
    /**
     * Use this to get a nullable value:
     * ```
     * const url: string|null = data.key('url').nullable.string
     * ```
     */
    get nullable(): UnsafeData | NullData;
    get string(): string;
    get boolean(): boolean;
    get number(): number;
    get integer(): number;
    get url(): URL;
    enum<T>(allowedValues: T[]): T;
    get array(): UnsafeData[];
    index(index: number): UnsafeData;
}
export {};
