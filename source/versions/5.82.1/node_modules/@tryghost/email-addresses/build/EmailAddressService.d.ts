import { EmailAddress } from './EmailAddressParser';
export type EmailAddresses = {
    from: EmailAddress;
    replyTo?: EmailAddress;
};
export type EmailAddressesValidation = {
    allowed: boolean;
    verificationEmailRequired: boolean;
    reason?: string;
};
export type EmailAddressType = 'from' | 'replyTo';
type LabsService = {
    isSet: (flag: string) => boolean;
};
export declare class EmailAddressService {
    #private;
    constructor(dependencies: {
        getManagedEmailEnabled: () => boolean;
        getSendingDomain: () => string | null;
        getDefaultEmail: () => EmailAddress;
        isValidEmailAddress: (email: string) => boolean;
        labs: LabsService;
    });
    get sendingDomain(): string | null;
    get managedEmailEnabled(): boolean;
    get useNewEmailAddresses(): boolean;
    get defaultFromEmail(): EmailAddress;
    getAddressFromString(from: string, replyTo?: string): EmailAddresses;
    /**
     * When sending an email, we should always ensure DMARC alignment.
     * Because of that, we restrict which email addresses we send from. All emails should be either
     * send from a configured domain (hostSettings.managedEmail.sendingDomains), or from the configured email address (mail.from).
     *
     * If we send an email from an email address that doesn't pass, we'll just default to the default email address,
     * and instead add a replyTo email address from the requested from address.
     */
    getAddress(preferred: EmailAddresses): EmailAddresses;
    /**
     * When changing any from or reply to addresses in the system, we need to validate them
     */
    validate(email: string, type: EmailAddressType): EmailAddressesValidation;
}
export {};
