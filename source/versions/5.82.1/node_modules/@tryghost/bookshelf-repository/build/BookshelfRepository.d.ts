import { Knex } from 'knex';
type Entity<T> = {
    id: T;
    deleted: boolean;
};
type Order<T> = {
    field: keyof T;
    direction: 'asc' | 'desc';
};
export type ModelClass<T> = {
    destroy: (data: {
        id: T;
    }) => Promise<void>;
    findOne: (data: {
        id: T;
    }, options?: {
        require?: boolean;
    }) => Promise<ModelInstance<T> | null>;
    add: (data: object) => Promise<ModelInstance<T>>;
    getFilteredCollection: (options: {
        filter?: string;
        mongoTransformer?: unknown;
    }) => {
        count(): Promise<number>;
        query: (f?: (q: Knex.QueryBuilder) => void) => Knex.QueryBuilder;
        fetchAll: () => Promise<ModelInstance<T>[]>;
    };
};
export type ModelInstance<T> = {
    id: T;
    get(field: string): unknown;
    set(data: object | string, value?: unknown): void;
    save(properties: object, options?: {
        autoRefresh?: boolean;
        method?: 'update' | 'insert';
    }): Promise<ModelInstance<T>>;
};
type OptionalPropertyOf<T extends object> = Exclude<{
    [K in keyof T]: T extends Record<K, Exclude<T[K], undefined>> ? never : K;
}[keyof T], undefined>;
export type OrderOption<T extends Entity<any> = any> = Order<T>[];
export type IncludeOption<T extends Entity<any> = any> = OptionalPropertyOf<T>[];
export type AllOptions<T extends Entity<any> = any> = {
    filter?: string;
    order?: OrderOption<T>;
    page?: number;
    limit?: number;
    include?: IncludeOption<T>;
};
export declare abstract class BookshelfRepository<IDType, T extends Entity<IDType>> {
    #private;
    protected Model: ModelClass<IDType>;
    constructor(Model: ModelClass<IDType>);
    protected abstract toPrimitive(entity: T): object;
    protected abstract modelToEntity(model: ModelInstance<IDType>): Promise<T | null> | T | null;
    protected abstract getFieldToColumnMap(): Record<keyof T, string>;
    /**
     * override this method to add custom query logic to knex queries
     */
    applyCustomQuery(query: Knex.QueryBuilder, options: AllOptions<T>): void;
    save(entity: T): Promise<void>;
    getById(id: IDType): Promise<T | null>;
    getAll({ filter, order, include }?: Omit<AllOptions<T>, 'page' | 'limit'>): Promise<T[]>;
    getPage({ filter, order, page, limit, include }: AllOptions<T> & Required<Pick<AllOptions<T>, 'page' | 'limit'>>): Promise<T[]>;
    getCount({ filter }?: {
        filter?: string;
    }): Promise<number>;
    getGroupedCount<K extends keyof T>({ filter, groupBy }: {
        filter?: string;
        groupBy: K;
    }): Promise<({
        count: number;
    } & Record<K, T[K]>)[]>;
}
export {};
