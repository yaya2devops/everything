{"version":3,"file":"kg-converters.js","sources":["../lib/lexical-to-mobiledoc.js","../lib/mobiledoc-to-lexical.js"],"sourcesContent":["const MOBILEDOC_VERSION = '0.3.1';\nconst GHOST_VERSION = '4.0';\n\nconst BLANK_DOC = {\n    version: MOBILEDOC_VERSION,\n    ghostVersion: GHOST_VERSION,\n    markups: [],\n    atoms: [],\n    cards: [],\n    sections: [\n        [1, 'p', [\n            [0, [], 0, '']\n        ]]\n    ]\n};\n\nconst MD_TEXT_SECTION = 1;\nconst MD_LIST_SECTION = 3;\nconst MD_CARD_SECTION = 10;\n\nconst MD_TEXT_MARKER = 0;\nconst MD_ATOM_MARKER = 1;\n\nconst L_IS_BOLD = 1;\nconst L_IS_ITALIC = 1 << 1;\nconst L_IS_STRIKETHROUGH = 1 << 2;\nconst L_IS_UNDERLINE = 1 << 3;\nconst L_IS_CODE = 1 << 4;\nconst L_IS_SUBSCRIPT = 1 << 5;\nconst L_IS_SUPERSCRIPT = 1 << 6;\n\nconst L_FORMAT_MAP = new Map([\n    [L_IS_BOLD, 'strong'],\n    [L_IS_ITALIC, 'em'],\n    [L_IS_STRIKETHROUGH, 's'],\n    [L_IS_UNDERLINE, 'u'],\n    [L_IS_CODE, 'code'],\n    [L_IS_SUBSCRIPT, 'sub'],\n    [L_IS_SUPERSCRIPT, 'sup']\n]);\n\nconst HEADING_TYPES = ['heading', 'extended-heading'];\nconst TEXT_TYPES = ['text', 'extended-text'];\n\n// TODO: Feels a little too explicit as it will need updating every time we add a new card.\n//\n// One alternative is to use a list of all built-in Lexical types and assume that anything\n// not listed is a card but that feels more dangerous.\n//\n// Another alternative is to grab the list of cards from kg-default-nodes but that's creating\n// more inter-dependencies that makes development setup tricky.\nconst KNOWN_CARDS = [\n    'audio',\n    'bookmark',\n    'button',\n    'callout',\n    'codeblock',\n    'email-cta',\n    'email',\n    'embed',\n    'file',\n    'gallery',\n    'header',\n    'horizontalrule',\n    'html',\n    'image',\n    'markdown',\n    'paywall',\n    'product',\n    'signup',\n    'toggle',\n    'video'\n];\n\nconst CARD_NAME_MAP = {\n    codeblock: 'code',\n    horizontalrule: 'hr'\n};\n\nconst CARD_PROPERTY_MAP = {\n    embed: {\n        embedType: 'type'\n    }\n};\n\nexport function lexicalToMobiledoc(serializedLexical) {\n    if (serializedLexical === null || serializedLexical === undefined || serializedLexical === '') {\n        return JSON.stringify(BLANK_DOC);\n    }\n\n    const lexical = JSON.parse(serializedLexical);\n\n    if (!lexical.root) {\n        return JSON.stringify(BLANK_DOC);\n    }\n\n    const mobiledoc = buildEmptyDoc();\n\n    lexical.root.children.forEach(child => addRootChild(child, mobiledoc));\n\n    return JSON.stringify(mobiledoc);\n}\n\n/* internal functions ------------------------------------------------------- */\n\nfunction buildEmptyDoc() {\n    return {\n        version: MOBILEDOC_VERSION,\n        ghostVersion: GHOST_VERSION,\n        atoms: [],\n        cards: [],\n        markups: [],\n        sections: []\n    };\n}\n\nfunction getOrSetMarkupIndex(markup, mobiledoc) {\n    let index = mobiledoc.markups.findIndex(m => m[0] === markup);\n\n    if (index === -1) {\n        mobiledoc.markups.push([markup]);\n        index = mobiledoc.markups.length - 1;\n    }\n\n    return index;\n}\n\nfunction getOrSetAtomIndex(atom, mobiledoc) {\n    let index = mobiledoc.atoms.findIndex(m => m[0] === atom);\n\n    if (index === -1) {\n        mobiledoc.atoms.push(atom);\n        index = mobiledoc.atoms.length - 1;\n    }\n\n    return index;\n}\n\nfunction addRootChild(child, mobiledoc) {\n    if (child.type === 'paragraph') {\n        addTextSection(child, mobiledoc);\n    }\n\n    if (HEADING_TYPES.includes(child.type)) {\n        addTextSection(child, mobiledoc, child.tag);\n    }\n\n    if (child.type === 'quote') {\n        addTextSection(child, mobiledoc, 'blockquote');\n    }\n\n    if (child.type === 'aside') {\n        addTextSection(child, mobiledoc, 'aside');\n    }\n\n    if (child.type === 'list') {\n        addListSection(child, mobiledoc, child.tag);\n    }\n\n    if (KNOWN_CARDS.includes(child.type)) {\n        addCardSection(child, mobiledoc);\n    }\n}\n\nfunction addTextSection(childWithFormats, mobiledoc, tagName = 'p') {\n    const markers = buildMarkers(childWithFormats, mobiledoc);\n    const section = [MD_TEXT_SECTION, tagName, markers];\n\n    mobiledoc.sections.push(section);\n}\n\nfunction addListSection(listChild, mobiledoc, tagName = 'ul') {\n    const listItems = buildListItems(listChild, mobiledoc);\n    const section = [MD_LIST_SECTION, tagName, listItems];\n\n    mobiledoc.sections.push(section);\n}\n\nfunction buildListItems(listRoot, mobiledoc) {\n    const listItems = [];\n\n    flattenListChildren(listRoot);\n\n    listRoot.children.forEach((listItemChild) => {\n        if (listItemChild.type === 'listitem') {\n            const markers = buildMarkers(listItemChild, mobiledoc);\n            listItems.push(markers);\n        }\n    });\n\n    return listItems;\n}\n\nfunction flattenListChildren(listRoot) {\n    const flatListItems = [];\n\n    function traverse(item) {\n        item.children?.forEach((child) => {\n            child.children?.forEach((grandchild) => {\n                if (grandchild.type === 'list') {\n                    traverse(grandchild);\n                    child.children.splice(child.children.indexOf(grandchild), 1);\n                }\n            });\n\n            if (child.type === 'listitem' && child.children.length) {\n                flatListItems.push(child);\n            }\n        });\n    }\n\n    traverse(listRoot);\n    listRoot.children = flatListItems;\n}\n\nfunction buildMarkers(childWithFormats, mobiledoc) {\n    const markers = [];\n\n    if (!childWithFormats.children.length) {\n        markers.push([MD_TEXT_MARKER, [], 0, '']);\n    } else {\n        // mobiledoc tracks opened/closed formats across markers whereas lexical\n        // lists all formats for each marker so we need to manually track open formats\n        let openMarkups = [];\n\n        // markup: a specific format, or tag name+attributes\n        // marker: a piece of text with 0 or more markups\n\n        childWithFormats.children.forEach((child, childIndex) => {\n            if (TEXT_TYPES.includes(child.type)) {\n                if (child.format !== 0) {\n                    // text child has formats, track which are new and which have closed\n                    const openedFormats = [];\n                    const childFormats = readFormat(child.format);\n                    let closedFormatCount = 0;\n\n                    childFormats.forEach((format) => {\n                        if (!openMarkups.includes(format)) {\n                            openMarkups.push(format);\n                            openedFormats.push(format);\n                        }\n                    });\n\n                    // mobiledoc will immediately close any formats if the next section doesn't use them or it's not a text section\n                    if (!childWithFormats.children[childIndex + 1] || !TEXT_TYPES.includes(childWithFormats.children[childIndex + 1].type)) {\n                        // no more children, close all formats\n                        closedFormatCount = openMarkups.length;\n                        openMarkups = [];\n                    } else {\n                        const nextChild = childWithFormats.children[childIndex + 1];\n                        const nextFormats = readFormat(nextChild.format);\n                        const firstMissingFormatIndex = openMarkups.findIndex(format => !nextFormats.includes(format));\n\n                        if (firstMissingFormatIndex !== -1) {\n                            const formatsToClose = openMarkups.slice(firstMissingFormatIndex);\n                            closedFormatCount = formatsToClose.length;\n                            openMarkups = openMarkups.slice(0, firstMissingFormatIndex);\n                        }\n                    }\n\n                    const markupIndexes = openedFormats.map(format => getOrSetMarkupIndex(format, mobiledoc));\n                    markers.push([MD_TEXT_MARKER, markupIndexes, closedFormatCount, child.text]);\n                } else {\n                    // text child has no formats so we close all formats in mobiledoc\n                    let closedFormatCount = openMarkups.length;\n                    openMarkups = [];\n\n                    markers.push([MD_TEXT_MARKER, [], closedFormatCount, child.text]);\n                }\n            }\n\n            if (child.type === 'link') {\n                const linkMarkup = ['a', ['href', child.url]];\n                const linkMarkupIndex = mobiledoc.markups.push(linkMarkup) - 1;\n\n                child.children.forEach((linkChild, linkChildIndex) => {\n                    if (linkChild.format !== 0) {\n                        const openedMarkupIndexes = [];\n                        const openedFormats = [];\n\n                        // first child of a link opens the link markup\n                        if (linkChildIndex === 0) {\n                            openMarkups.push(linkMarkup);\n                            openedMarkupIndexes.push(linkMarkupIndex);\n                        }\n\n                        // text child has formats, track which are new and which have closed\n                        const childFormats = readFormat(linkChild.format);\n                        let closedMarkupCount = 0;\n\n                        childFormats.forEach((format) => {\n                            if (!openMarkups.includes(format)) {\n                                openMarkups.push(format);\n                                openedFormats.push(format);\n                            }\n                        });\n\n                        // mobiledoc will immediately close any formats if the next section doesn't use them\n                        if (!child.children[linkChildIndex + 1]) {\n                            // last child of a link closes all markups\n                            closedMarkupCount = openMarkups.length;\n                            openMarkups = [];\n                        } else {\n                            const nextChild = child.children[linkChildIndex + 1];\n                            const nextFormats = readFormat(nextChild.format);\n\n                            const firstMissingFormatIndex = openMarkups.findIndex((markup) => {\n                                const markupIsLink = JSON.stringify(markup) === JSON.stringify(linkMarkup);\n                                return !markupIsLink && !nextFormats.includes(markup);\n                            });\n\n                            if (firstMissingFormatIndex !== -1) {\n                                const formatsToClose = openMarkups.slice(firstMissingFormatIndex);\n                                closedMarkupCount = formatsToClose.length;\n                                openMarkups = openMarkups.slice(0, firstMissingFormatIndex);\n                            }\n                        }\n\n                        openedMarkupIndexes.push(...openedFormats.map(format => getOrSetMarkupIndex(format, mobiledoc)));\n\n                        markers.push([MD_TEXT_MARKER, openedMarkupIndexes, closedMarkupCount, linkChild.text]);\n                    } else {\n                        const openedMarkupIndexes = [];\n\n                        // first child of a link opens the link markup\n                        if (linkChildIndex === 0) {\n                            openMarkups.push(linkMarkup);\n                            openedMarkupIndexes.push(linkMarkupIndex);\n                        }\n\n                        let closedMarkupCount = openMarkups.length - 1; // don't close the link markup, just the others\n\n                        // last child of a link closes all markups\n                        if (!child.children[linkChildIndex + 1]) {\n                            closedMarkupCount += 1; // close the link markup\n                            openMarkups = [];\n                        }\n\n                        markers.push([MD_TEXT_MARKER, openedMarkupIndexes, closedMarkupCount, linkChild.text]);\n                    }\n                });\n            }\n\n            if (child.type === 'linebreak') {\n                const atom = ['soft-return', '', {}];\n                const atomIndex = getOrSetAtomIndex(atom, mobiledoc);\n                markers.push([MD_ATOM_MARKER, [], 0, atomIndex]);\n            }\n        });\n    }\n\n    return markers;\n}\n\n// Lexical stores formats as a bitmask, so we need to read the bitmask to\n// determine which formats are present\nfunction readFormat(format) {\n    const formats = [];\n\n    L_FORMAT_MAP.forEach((value, key) => {\n        if ((format & key) !== 0) {\n            formats.push(value);\n        }\n    });\n\n    return formats;\n}\n\nfunction addCardSection(child, mobiledoc) {\n    const cardType = child.type;\n\n    let cardName = child.type;\n    // rename card if there's a difference between lexical/mobiledoc\n    if (CARD_NAME_MAP[cardName]) {\n        cardName = CARD_NAME_MAP[cardName];\n    }\n    // don't include type in the payload\n    delete child.type;\n\n    // rename any properties to match mobiledoc\n    if (CARD_PROPERTY_MAP[cardType]) {\n        const map = CARD_PROPERTY_MAP[cardType];\n\n        for (const [key, value] of Object.entries(map)) {\n            child[value] = child[key];\n            delete child[key];\n        }\n    }\n\n    const card = [cardName, child];\n    mobiledoc.cards.push(card);\n\n    const cardIndex = mobiledoc.cards.length - 1;\n    const section = [MD_CARD_SECTION, cardIndex];\n\n    mobiledoc.sections.push(section);\n}\n","const BLANK_DOC = {\n    root: {\n        children: [],\n        direction: null,\n        format: '',\n        indent: 0,\n        type: 'root',\n        version: 1\n    }\n};\n\nconst TAG_TO_LEXICAL_NODE = {\n    p: {\n        type: 'paragraph'\n    },\n    h1: {\n        type: 'heading',\n        tag: 'h1'\n    },\n    h2: {\n        type: 'heading',\n        tag: 'h2'\n    },\n    h3: {\n        type: 'heading',\n        tag: 'h3'\n    },\n    h4: {\n        type: 'heading',\n        tag: 'h4'\n    },\n    h5: {\n        type: 'heading',\n        tag: 'h5'\n    },\n    h6: {\n        type: 'heading',\n        tag: 'h6'\n    },\n    blockquote: {\n        type: 'quote'\n    },\n    aside: {\n        type: 'aside'\n    },\n    a: {\n        type: 'link',\n        rel: null,\n        target: null,\n        title: null,\n        url: null\n    }\n};\n\nconst ATOM_TO_LEXICAL_NODE = {\n    'soft-return': {\n        type: 'linebreak',\n        version: 1\n    }\n};\n\nconst MARKUP_TO_FORMAT = {\n    strong: 1,\n    b: 1,\n    em: 1 << 1,\n    i: 1 << 1,\n    s: 1 << 2,\n    u: 1 << 3,\n    code: 1 << 4,\n    sub: 1 << 5,\n    sup: 1 << 6\n};\n\nconst CARD_NAME_MAP = {\n    code: 'codeblock',\n    hr: 'horizontalrule'\n};\n\nconst CARD_PROPERTY_MAP = {\n    embed: {\n        type: 'embedType'\n    }\n};\n\nconst CARD_FIXES_MAP = {\n    callout: (payload) => {\n        if (payload.backgroundColor && !payload.backgroundColor.match(/^[a-zA-Z\\d-]+$/)) {\n            payload.backgroundColor = 'white';\n        }\n\n        return payload;\n    }\n};\n\nexport function mobiledocToLexical(serializedMobiledoc) {\n    if (serializedMobiledoc === null || serializedMobiledoc === undefined || serializedMobiledoc === '') {\n        return JSON.stringify(BLANK_DOC);\n    }\n\n    const mobiledoc = JSON.parse(serializedMobiledoc);\n\n    if (!mobiledoc.sections) {\n        return JSON.stringify(BLANK_DOC);\n    }\n\n    const lexical = buildEmptyDoc();\n\n    mobiledoc.sections.forEach(child => addRootChild(child, mobiledoc, lexical));\n\n    return JSON.stringify(lexical);\n}\n\n/* internal functions ------------------------------------------------------- */\n\nfunction buildEmptyDoc() {\n    return {\n        root: {\n            children: [],\n            direction: null,\n            format: '',\n            indent: 0,\n            type: 'root',\n            version: 1\n        }\n    };\n}\n\nfunction addRootChild(child, mobiledoc, lexical) {\n    const sectionTypeIdentifier = child[0];\n    if (sectionTypeIdentifier === 1) {\n        // Markup (text) section\n        const lexicalChild = convertMarkupSectionToLexical(child, mobiledoc);\n        lexical.root.children.push(lexicalChild);\n\n        // Set direction to ltr if there is any text\n        // Otherwise direction should be null\n        // Not sure if this is necessary:\n        // if we don't plan to support RTL, we could just set 'ltr' in all cases and ignore null\n        if (lexicalChild.children?.length > 0) {\n            lexical.root.direction = 'ltr';\n        }\n    } else if (sectionTypeIdentifier === 2) {\n        // Image section\n        // Not used in Ghost\n    } else if (sectionTypeIdentifier === 3) {\n        // List section\n        const lexicalChild = convertListSectionToLexical(child, mobiledoc);\n        lexical.root.children.push(lexicalChild);\n        lexical.root.direction = 'ltr'; // mobiledoc only supports LTR\n    } else if (sectionTypeIdentifier === 10) {\n        // Card section\n        const lexicalChild = convertCardSectionToLexical(child, mobiledoc);\n        lexical.root.children.push(lexicalChild);\n    }\n}\n\nfunction convertMarkupSectionToLexical(section, mobiledoc) {\n    const tagName = section[1]; // e.g. 'p'\n    const markers = section[2]; // e.g. [[0, [0], 0, \"Hello world\"]]\n\n    // Create an empty Lexical node from the tag name\n    // We will add nodes to the children array later\n    const lexicalNode = createEmptyLexicalNode(tagName);\n\n    populateLexicalNodeWithMarkers(lexicalNode, markers, mobiledoc);\n\n    return lexicalNode;\n}\n\nfunction populateLexicalNodeWithMarkers(lexicalNode, markers, mobiledoc) {\n    const markups = mobiledoc.markups;\n    const atoms = mobiledoc.atoms;\n\n    // Initiate some variables before looping over all the markers\n    let openMarkups = []; // tracks which markup tags are open for the current marker\n    let linkNode = undefined; // tracks current link node or undefined if no a tag is open\n    let href = undefined; // tracks the href for the current link node or undefined if no a tag is open\n    let rel = undefined; //tracks the rel attribute for the current link node or undefined if no a tag is open\n    let openLinkMarkup = false; // tracks whether the current node is a link node\n\n    // loop over markers and convert each one to lexical\n    for (let i = 0; i < markers.length; i++) {\n        // grab the attributes from the current marker\n        const [\n            textTypeIdentifier,\n            openMarkupsIndexes,\n            numberOfClosedMarkups,\n            value\n        ] = markers[i];\n\n        // Markers are either text (markup) or atoms\n        const markerType = textTypeIdentifier === 0 ? 'markup' : 'atom';\n\n        // If the current marker is an atom, convert the atom to Lexical and add to the node\n        if (markerType === 'atom') {\n            const atom = atoms[value];\n            const atomName = atom[0];\n            const childNode = ATOM_TO_LEXICAL_NODE[atomName];\n            embedChildNode(lexicalNode, childNode);\n            continue;\n        }\n\n        // calculate which markups are open for the current marker\n        openMarkupsIndexes.forEach((markupIndex) => {\n            const markup = markups[markupIndex];\n            // Extract the href from the markup if it's a link\n            if (markup[0] === 'a') {\n                openLinkMarkup = true;\n                if (markup[1] && markup[1][0] === 'href') {\n                    href = markup[1][1];\n                }\n\n                if (markup[1] && markup[1][2] === 'rel') {\n                    rel = markup[1][3];\n                }\n            }\n            // Add the markup to the list of open markups\n            openMarkups.push(markup);\n        });\n\n        if (value !== undefined) {\n            // Convert the open markups to a bitmask compatible with Lexical\n            const format = convertMarkupTagsToLexicalFormatBitmask(openMarkups);\n\n            // If there is an open link tag, add the text to the link node\n            // Otherwise add the text to the parent node\n            if (openLinkMarkup) { // link is open\n                // Create an empty link node if it doesn't exist already\n                linkNode = linkNode !== undefined ? linkNode : createEmptyLexicalNode('a', {url: href, rel: rel || null});\n\n                // Create a text node and add it to the link node\n                const textNode = createTextNode(value, format);\n                embedChildNode(linkNode, textNode);\n            } else {\n                const textNode = createTextNode(value, format);\n                embedChildNode(lexicalNode, textNode);\n            }\n        }\n\n        // Close any markups that are closed after the current marker\n        // Remove any closed markups from openMarkups list\n        for (let j = 0; j < numberOfClosedMarkups; j++) {\n            // Remove the most recently opened markup from the list of open markups\n            const markup = openMarkups.pop();\n\n            // If we're closing a link tag, add the linkNode to the node\n            // Reset href and linkNode for the next markup\n            if (markup && markup[0] === 'a') {\n                embedChildNode(lexicalNode, linkNode);\n                openLinkMarkup = false;\n                href = undefined;\n                linkNode = undefined;\n            }\n        }\n    }\n}\n\n// Creates a text node from the given text and format\nfunction createTextNode(text, format) {\n    return {\n        detail: 0,\n        format: format,\n        mode: 'normal',\n        style: '',\n        text: text,\n        type: 'text',\n        version: 1\n    };\n}\n\n// Creates an empty Lexical node from the given tag name and additional attributes\nfunction createEmptyLexicalNode(tagName, attributes = {}) {\n    const nodeParams = TAG_TO_LEXICAL_NODE[tagName];\n    const node = {\n        children: [],\n        direction: 'ltr',\n        format: '',\n        indent: 0,\n        ...nodeParams,\n        ...attributes,\n        version: 1\n    };\n    return node;\n}\n\n// Adds a child node to a parent node\nfunction embedChildNode(parentNode, childNode) {\n    // If there is no child node, do nothing\n    if (!childNode) {\n        return;\n    }\n    // Add textNode to node's children\n    parentNode.children.push(childNode);\n\n    // If there is any text (e.g. not a blank text node), set the direction to ltr\n    if (childNode && 'text' in childNode && childNode.text) {\n        parentNode.direction = 'ltr';\n    }\n}\n\n// Lexical stores formats as a bitmask\n// Mobiledoc stores formats as a list of open markup tags\n// This function converts a list of open tags to a bitmask compatible with lexical\nfunction convertMarkupTagsToLexicalFormatBitmask(tags) {\n    let format = 0;\n    tags.forEach((tag) => {\n        if (tag in MARKUP_TO_FORMAT) {\n            format = format | MARKUP_TO_FORMAT[tag];\n        }\n    });\n    return format;\n}\n\nfunction convertListSectionToLexical(child, mobiledoc) {\n    const tag = child[1];\n    const listType = tag === 'ul' ? 'bullet' : 'number';\n    const listNode = createEmptyLexicalNode(tag, {tag, type: 'list', listType, start: 1, direction: 'ltr'});\n\n    child[2]?.forEach((listItem, i) => {\n        const listItemNode = createEmptyLexicalNode('li', {type: 'listitem', value: i + 1, direction: 'ltr'});\n        populateLexicalNodeWithMarkers(listItemNode, listItem, mobiledoc);\n        listNode.children.push(listItemNode);\n    });\n\n    return listNode;\n}\n\nfunction convertCardSectionToLexical(child, mobiledoc) {\n    let [cardName, payload] = mobiledoc.cards[child[1]];\n\n    // rename card if there's a difference between mobiledoc and lexical\n    cardName = CARD_NAME_MAP[cardName] || cardName;\n\n    // rename any properties to match lexical\n    if (CARD_PROPERTY_MAP[cardName]) {\n        const map = CARD_PROPERTY_MAP[cardName];\n\n        for (const [oldName, newName] of Object.entries(map)) {\n            payload[newName] = payload[oldName];\n            delete payload[oldName];\n        }\n    }\n\n    // run any payload fixes\n    if (CARD_FIXES_MAP[cardName]) {\n        payload = CARD_FIXES_MAP[cardName](payload);\n    }\n\n    delete payload.type;\n    const decoratorNode = {type: cardName, ...payload};\n\n    return decoratorNode;\n}\n"],"names":["MOBILEDOC_VERSION","GHOST_VERSION","BLANK_DOC","version","ghostVersion","markups","atoms","cards","sections","MD_TEXT_SECTION","MD_LIST_SECTION","MD_CARD_SECTION","MD_TEXT_MARKER","MD_ATOM_MARKER","L_IS_BOLD","L_IS_ITALIC","L_IS_STRIKETHROUGH","L_IS_UNDERLINE","L_IS_CODE","L_IS_SUBSCRIPT","L_IS_SUPERSCRIPT","L_FORMAT_MAP","Map","HEADING_TYPES","TEXT_TYPES","KNOWN_CARDS","CARD_NAME_MAP","codeblock","horizontalrule","CARD_PROPERTY_MAP","embed","embedType","lexicalToMobiledoc","serializedLexical","undefined","JSON","stringify","lexical","parse","root","mobiledoc","buildEmptyDoc","children","forEach","child","addRootChild","getOrSetMarkupIndex","markup","index","findIndex","m","push","length","getOrSetAtomIndex","atom","type","addTextSection","includes","tag","addListSection","addCardSection","childWithFormats","tagName","markers","buildMarkers","section","listChild","listItems","buildListItems","listRoot","flattenListChildren","listItemChild","flatListItems","traverse","item","grandchild","splice","indexOf","openMarkups","childIndex","format","openedFormats","childFormats","readFormat","closedFormatCount","nextChild","nextFormats","firstMissingFormatIndex","formatsToClose","slice","markupIndexes","map","text","linkMarkup","url","linkMarkupIndex","linkChild","linkChildIndex","openedMarkupIndexes","closedMarkupCount","markupIsLink","atomIndex","formats","value","key","cardType","cardName","Object","entries","card","cardIndex","direction","indent","TAG_TO_LEXICAL_NODE","p","h1","h2","h3","h4","h5","h6","blockquote","aside","a","rel","target","title","ATOM_TO_LEXICAL_NODE","MARKUP_TO_FORMAT","strong","b","em","i","s","u","code","sub","sup","hr","CARD_FIXES_MAP","callout","payload","backgroundColor","match","mobiledocToLexical","serializedMobiledoc","sectionTypeIdentifier","lexicalChild","convertMarkupSectionToLexical","convertListSectionToLexical","convertCardSectionToLexical","lexicalNode","createEmptyLexicalNode","populateLexicalNodeWithMarkers","linkNode","href","openLinkMarkup","textTypeIdentifier","openMarkupsIndexes","numberOfClosedMarkups","markerType","atomName","childNode","embedChildNode","markupIndex","convertMarkupTagsToLexicalFormatBitmask","textNode","createTextNode","j","pop","detail","mode","style","attributes","nodeParams","node","parentNode","tags","listType","listNode","start","listItem","listItemNode","oldName","newName","decoratorNode"],"mappings":"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"}