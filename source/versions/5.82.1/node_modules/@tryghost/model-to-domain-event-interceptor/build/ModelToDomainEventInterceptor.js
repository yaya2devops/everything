"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ModelToDomainEventInterceptor = void 0;
const post_events_1 = require("@tryghost/post-events");
const collections_1 = require("@tryghost/collections");
class ModelToDomainEventInterceptor {
    ModelEvents;
    DomainEvents;
    constructor(deps) {
        this.ModelEvents = deps.ModelEvents;
        this.DomainEvents = deps.DomainEvents;
    }
    init() {
        const ghostModelUpdateEvents = [
            'post.added',
            'post.deleted',
            'post.edited',
            // NOTE: currently unmapped and unused event
            'tag.added',
            'tag.deleted'
        ];
        for (const modelEventName of ghostModelUpdateEvents) {
            if (!this.ModelEvents.hasRegisteredListener(modelEventName, 'collectionListener')) {
                const dispatcher = this.domainEventDispatcher.bind(this);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const listener = function (data) {
                    dispatcher(modelEventName, data);
                };
                Object.defineProperty(listener, 'name', { value: `${modelEventName}.domainEventInterceptorListener`, writable: false });
                this.ModelEvents.on(modelEventName, listener);
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    domainEventDispatcher(modelEventName, data) {
        let event;
        switch (modelEventName) {
            case 'post.deleted':
                event = post_events_1.PostDeletedEvent.create({
                    id: data.id || data._previousAttributes?.id
                });
                break;
            case 'post.added':
                event = collections_1.PostAddedEvent.create({
                    id: data.id,
                    featured: data.attributes.featured,
                    status: data.attributes.status,
                    published_at: data.attributes.published_at
                });
                break;
            case 'post.edited':
                event = collections_1.PostEditedEvent.create({
                    id: data.id,
                    current: {
                        id: data.id,
                        title: data.attributes.title,
                        status: data.attributes.status,
                        featured: data.attributes.featured,
                        published_at: data.attributes.published_at,
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        tags: data.relations?.tags?.models.map((tag) => ({
                            slug: tag.get('slug')
                        }))
                    },
                    // @NOTE: this will need to represent the previous state of the post
                    //        will be needed to optimize the query for the collection
                    previous: {
                        id: data.id,
                        title: data._previousAttributes?.title,
                        status: data._previousAttributes?.status,
                        featured: data._previousAttributes?.featured,
                        published_at: data._previousAttributes?.published_at,
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        tags: data._previousRelations?.tags?.models.map((tag) => ({
                            slug: tag.get('slug')
                        }))
                    }
                });
                break;
            case 'tag.deleted':
                event = collections_1.TagDeletedEvent.create({
                    id: data.id || data._previousAttributes?.id,
                    slug: data.attributes?.slug || data._previousAttributes?.slug
                });
                break;
            default:
        }
        if (event) {
            this.DomainEvents.dispatch(event);
        }
    }
}
exports.ModelToDomainEventInterceptor = ModelToDomainEventInterceptor;
//# sourceMappingURL=ModelToDomainEventInterceptor.js.map