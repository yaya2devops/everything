"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalExceptionFilter = void 0;
const common_1 = require("@nestjs/common");
let GlobalExceptionFilter = class GlobalExceptionFilter {
    catch(error, host) {
        const context = host.switchToHttp();
        const response = context.getResponse();
        response.status(error.statusCode || 500);
        response.json({
            errors: [
                {
                    message: error.message,
                    context: error.context || null,
                    type: error.errorType || null,
                    details: error.errorDetails || null,
                    property: error.property || null,
                    help: error.help || null,
                    code: error.code || null,
                    id: error.id || null,
                    ghostErrorCode: error.ghostErrorCode || null
                }
            ]
        });
    }
};
exports.GlobalExceptionFilter = GlobalExceptionFilter;
exports.GlobalExceptionFilter = GlobalExceptionFilter = __decorate([
    (0, common_1.Catch)()
], GlobalExceptionFilter);
/*
function prepareError(err: unknown) {
    if (Array.isArray(err)) {
        err = err[0];
    }

    // If the error is already a GhostError, it has been handled and can be returned as-is
    // For everything else, we do some custom handling here
    if (errors.utils.isGhostError(err)) {
        return err;
    }

    if (!(err instanceof Error)) {
        return new errors.InternalServerError({
            err: err,
            message: tpl(messages.genericError),
            context: err.message,
            statusCode: err.statusCode,
            code: 'UNEXPECTED_ERROR'
        });
    }

    // Catch bookshelf empty errors and other 404s, and turn into a Ghost 404
    if (
        (err.statusCode && err.statusCode === 404) ||
        err.message === 'EmptyResponse'
    ) {
        return new errors.NotFoundError({
            err: err
        });
        // Catch handlebars / express-hbs errors, and render them as 400, rather than 500 errors as the server isn't broken
    } else if (
        isDependencyInStack('handlebars', err) ||
        isDependencyInStack('express-hbs', err)
    ) {
        // Temporary handling of theme errors from handlebars
        // @TODO remove this when #10496 is solved properly
        err = new errors.IncrrectUsageError({
            err: err,
            message: err.message,
            statusCode: err.statusCode
        });
        // Catch database errors and turn them into 500 errors, but log some useful data to sentry
    } else if (isDependencyInStack('mysql2', err)) {
        // we don't want to return raw database errors to our users
        err.sqlErrorCode = err.code;
        err = new errors.InternalServerError({
            err: err,
            message: tpl(messages.genericError),
            statusCode: err.statusCode,
            code: 'UNEXPECTED_ERROR'
        });
        // For everything else, create a generic 500 error, with context set to the original error message
    } else {
        err = new errors.InternalServerError({
            err: err,
            message: tpl(messages.genericError),
            context: err.message,
            statusCode: err.statusCode,
            code: 'UNEXPECTED_ERROR'
        });
    }
}
*/
//# sourceMappingURL=global-exception.filter.js.map